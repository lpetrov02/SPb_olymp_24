### Алгоритм  
Предлагаемое решение работает для углов поворота от -90 до 89 градусов (включительно). Это разумное ограничение, так как при фотографировании текста часто получается кривое фото, но большие углы поворота - всё же довольно редкое явление (если специально не стараться). На практике, скорее всего, большинство привых фоторгафий повёрнуты не более, чем на 45 градусов.  
Сконвертируем картинку с 2D посредством библиотеки pillow.  
Рассмторим все углы от -90 до 89 градусов включительно и выберем среди них наиболее подходящий.  
Для каждого угла-кандидата:  
1. Применим к исходному изображению поворот на рассматриваемый угол - результат запишем в новую переменную.  
3. Посчитаем сумму значений пикселей по строкам. Посчитаем дисперсию выборки значений построчных сумм. Если картика повёрнута правильно, то строки будут захватывать то текст, то только фон, и из-за этого значения сумм пикселей в строках будут сильно отличаться, и дисперсия будет большой.  
4. Значение угла, для которого дисперсия максимальна - и есть ответ, который вернёт алгоритм.  

Далее вспомогательная функция получит угол поворота и выполнит обратный поворот.  

### Использование ресурсов  
- Из дополнительной памяти нам нужна дополнительная картинка - куда мы будем сохранять результаты поворота при подборе нужного угла. Стоит отметить, что результаты поворота можно записывать в одну и ту же переменную, так что памяти это потребует довольно немного. Также нужен массив из 180 float-ов - туда будем записывать значения дисперсии для каждого из углов.  
- По времени самая затратная операция - это поворот. Она подразумевает перемещение всех пикселей и выполняется 180 раз (для каждого угла от -90 до 90). Но на практике это довольно быстро.  
- Алгоритм не подразумевает итераций по самой картинке, которые обычно очень долгие. Просто поворот, а потом - использование *numpy* для подсчёта построчных сумм и дисперсий. Векторные операции, реализованные в этой библиотеке также работаю быстро.  
- Алгоритм не отличает углы поворота с разницей 180 градусов, но это и не требуется, так как подразумевается, что модуль угла поворота меньше 90 градусов (можно от -90 до 89 включтельно).  

### Что где смотреть в репозитории (ссылка ниже):  
1. В файле *task2.py* приведён код алгоритма.  
    - Функция *find_angle* находит угол, на который было повёрнуто изображение, а *unrotate* поворачивает изображение назад (и возвращает угол поворота).  
    - Как запустить: в директории *task2* выполнить команду `python3 ./task2.py "rotated_picture.jpg" "save_result_here.jpg"`, где первый путь - до повёрнутого изображения, а второй указывает, куда сохранить результат (выровненное изображение).  
2. В *src* можно найти примеры картинок.  
3. В *benchmarking* лежит *ipython notebook* с экспериментами, а также 6 картинок, нужных для эксперимента. Алгоритм отлично справился с определением угла поворота на всех картинках (подробнее - см. *benchmarking/task2_tests.ipynb*)  
