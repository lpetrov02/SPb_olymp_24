# Задание 1. Судоку.  
### Полный перебор  
Чтобы решить судоку, нужно корректно заполнить все клетки таблицы (игрового поля). Первое, самое наивное, решение - это полный перебор.  
Обозначим за $n$ сторону игрового поля. Всего клеток $n^2$, и в каждой может быть $n$ возможных значений. Всего $O(n^{n^2})$ - это уже очень много даже для классического судоку 9х9.

### Перебор с отсечением  
Нетрудно заметить, что большинство из упомянутых выше $n^{n^2}$ вариантов заведомо не реализуемы, так как там нет никаких ограничений на повторяемость чисел в строках, столбцах и в маленьких "квадратиках" (так назовём квадраты $\sqrt{n} \times \sqrt{n}$, в которых также не должно быть повторений).  
Поэтому для каждой клетки поля можно хранить множество чисел, которые могут быть вписаны в клетку. Таких чисел не больше $n$. Эти множества назовём множествами кандидатов.  
Игру можно рассмотреть как граф состояний, где вершина - это частично или полностью (конечное состояние) заполненная табличка, а ребро - заполнение конкретной клетки конкретным числом. И наша задача - найти конечное состояние в графе.  
Заполняя клетку числом $k$, следует пройтись по всем клеткам того же столбца, той же строки и того же "квадратика" - и для всех незаполненных вычеркнуть $k$ из множества кандидатов. Потом, если для какой-то пустой клетки не осталось вариантов, то состояние точно не является валидным, и можно сразу искать дальше. А если для пустой клетки остался один вариант, то следует сразу заполнить клетку единственным кандидатом.

### Решение на основе эвристического поиска  
У выше описанного подхода есть проблема: не понятно, в каком порядке выбирать очередное состояние для дальнейшего заполнения числами. Для этого я использовал эвристики.  
Наиболее приоритетными считаются состояния, для которых осталось заполнить меньше всего клеток. Количество незаполненных клеток - это ровно количество шагов до конечного состояния, а его хочется делать с каждой итерацией всё меньше и меньше.  

### Алгоритм  
Процедура упрощения: иногда для каких-то клеток остаётся всего по 1 кандидату. Назовём эти клетки детерминированными.  
Процедура упрощения подразумевает:  
1. Для каждой детерминированной клетки:  
    - Заполнить её единственным кандидатом.  
    - Вычеркнуть этого кандидата из множеств кандидатов всех клеток того же столбца, той же строки и того же "квадратика".  
    - Если на предыдущем шаге появились новые детерминированные клетки, то повторить, начиная с п. 1.  

2. Алгоритм:  
    1. Если сторона таблички - не полный квадрат, то такое поле не валидно. Поле $0 \times 0$ будем также считать невалидным.  
    2. Класс *Node* - состояние. Хранит в себе табличку $n \times n$, где каждая ячейка содержит значение - это число от $1$ до $n$, если она заполнена, или $0$, если она пуста. Для каждой пустой ячейки хранится множество кандидатов.  
    3. Считывается начальное состояние, и для него выполняется процедура упрощения.  
    4. Есть куча состояний (в данном случае куча - это термин, названеи структуры данных). Изначально в куче есть только одно - начальное - состояние. Алгоритм работает пока не будет найдено конечное состояние или пока куча не станет пустой.  
    5. На каждом шаге из кучи извлекается состояние с наименьшим числом пустых клеток. Если пустых клеток нет, то извлечённое состояние - конечное. Следует вывести табличку данного состояния и завершить исполнение.  
    6. Если извлечённое состояние не являестя конечным, в его табличке ищется пустая ячейка с минимальным (по мощности) множеством кандидатов. Для каждого кандидата создаётся своё состояние, где кандидат вписан в рассматриваемую ячейку.  
    7. Для каждого вновь созданного состояния запускается процедура упрощения. Если новое состояние валидно (то есть удовлетворяет правилам игры), оно добавляется в кучу.  
    8. Повторить, начиная с п.5.  

### Варианты распараллеливания
Самое долгое действие - копирование всего игрового поля при создании новых состояний.  
После извлечения объекта из кучи, сам объект не меняется, поэтому можно его копировать параллельно. Только потом, при добавлении новых элементов обратно в кучу, стоит делать это атомарно, при помощи мьютекса, чтобы несколько потоков не изменяли одну и ту же область памяти.  
